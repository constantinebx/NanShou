Redis设计与实现
===
目录
---
[第二章 简单动态字符串](#第二章-简单动态字符串)

>[2.1 SDS的定义](#21-SDS的定义)

>[2.2 SDS 与 C 字符串的区别](#22-SDS-与-C-字符串的区别)

>>[2.2.1 常数复杂度获取字符串长度](#221-常数复杂度获取字符串长度)

>>[2.2.2 杜绝缓冲区溢出](#222-杜绝缓冲区溢出)

>>[2.2.3 减少修改字符串时带来的内存重分配次数](#223-减少修改字符串时带来的内存重分配次数)

>>[2.2.4 二进制安全](#224-二进制安全)

[第三章 链表](#第三章-链表)

>[3.1 链表和链表节点的实现](#31-链表和链表节点的实现)

[第四章 字典](#第四章-字典)

>[4.1 字典的实现](#41-字典的实现)

>>[4.1.1 哈希表](#411-哈希表)

>>[4.1.2 哈希表节点](#412-哈希表节点)

>>[4.1.3 字典](#413-字典)

>[4.2 哈希算法](#42-哈希算法)

>[4.3 解决键冲突](#43-解决键冲突)

>[4.4 rehash](#44-rehash)

>[4.5 渐进式rehash](#45-渐进式rehash)

[第五章 跳跃表](#第五章-跳跃表)

## 第二章 简单动态字符串
Redis没有使用C语言传统的字符串（以空字符结尾的字符数组）表示，而是自己构建了一种名为简单动态字符串的类型（simple dynamic string，SDS），并将其作为Redis的默认字符串表示。

### 2.1 SDS的定义
每个sds.h/sdshdr结构表示一个SDS的值：  
```C
struct sdshdr {
    // 记录buf数组中已经使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    car buf[];
}
```
示例，将Redis字符串使用SDS保存，则：  
free属性的值为0，表示这个SDS没有分配任何未使用空间；  
len属性的值为5，表示这个SDS保存了一个五字节长的字符串；  
buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，最后一个字节则保存了空的字符串'\0'。  
保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符串到字符串末尾等操作，都是由SDS函数自动完成的。  
遵循这一惯例的好处是，SDS可以直接使用一部分C字符函数库里面的函数。  

### 2.2 SDS 与 C 字符串的区别
#### 2.2.1 常数复杂度获取字符串长度
SDS的len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)。  
设置和更新SDS长度的工作是由SDS API在执行时自动完成的，使用SDS无需进行任何手动修改长度的操作。  

#### 2.2.2 杜绝缓冲区溢出
当SDS API许哟对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才
执行实际的修改操作。  

#### 2.2.3 减少修改字符串时带来的内存重分配次数
如果程序执行增加字符串的操作，那么在执行这个操作之前，需要先通过内存重分配来扩展底层数组的大小，如果忘了这个步骤就会产生缓冲区溢出。  
如果程序执行缩短字符串的操作，那么在执行操作之后，需要通过内存重分配来释放字符串不再使用的那部分空间，如果忘了这个步骤就会产生内存泄漏。  
因为内存重分配设计复杂的算法，并且可能需要执行系统调用，所以他通常是一个比较耗时的操作：  
在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的；  
但是Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的
时间就会占去修改字符串所用时间的一大部分，如果频繁的修改，可能还会对性能造成影响。  
为了避免这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的
字节，而这些字节的数量就由SDS的free属性记录。  
通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。  
1. 空间预分配  
空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会
为SDS分配额外的未使用空间。其中额外分配的未使用空间数量由以下公式决定：
如果对SDS进行修改之后，SDS的长度（len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间；
如果对SDS进行修改之后，SDS的长度将大于1MB，那么程序会分配1MB的未使用空间。
2. 惰性空间释放  
惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free
属性将这些字节的数量记录起来，并等待将来使用。
同时，SDS也提供了相应的API，让我们可以在有需要的时候，真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。

#### 2.2.4 二进制安全
C字符串中的字符必须符合某种编码（如ASCII），并且认为除了字符串的末尾，字符串里面不能包含空字符，否则最先被程序读入的空字符将会被误认为时字符串结尾，
这些限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频等二进制数据。
SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据组任何限制、过滤、或者假设，
写入是什么样，读取时就是什么样。  
这也是我们将SDS的buf属性成为字节数组的原因——Redis不是用这个数组来保存字符，而使用他来保存一系列二进制数据。

## 第三章 链表
链表被广泛用于实现Redis各种功能，比如列表键、发布与订阅、慢查询、监视器等。  
### 3.1 链表和链表节点的实现
每个链表节点使用一个adlist.h/listNode结构来表示：  
```C
typedef struct listNode {
    // 前置节点
    struct listNode * prev;
    // 后置节点
    struct listNode * next;
    // 节点的值
    void * value;
}listNode;
```
虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：  
```C
typedef struct list {
    listNode * head;
    listNode * tail;
    unsigned long len;
    void * (*dup) (void *ptr);
    void * (*free) (void *ptr);
    int (*match) (void *ptr,void *key);
} list;
```
list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：  
dup函数用于复制链表节点所保存的值；  
free函数用于释放链表节点所保存的值；  
match函数用于对比链表节点所保存的值和另一个输入值是否相等。  
Redis的链表实现的特性可以总结如下：  
双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1);  
无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点；  
带表头指针和表尾指针：获取链表头节点和尾节点的复杂度为O(1)；  
带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，获取节点数量复杂度为O（1）；  
多态：链表节点使用void * 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点设置类型特定函数，所以链表可以用于保存各种类型值。  

## 第四章 字典
字典又称为符号表、关联数组或者映射，是一种用于保存键值对的抽象数据结构。  
### 4.1 字典的实现
Redis使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。  
#### 4.1.1 哈希表
Redis字典所使用的哈希表由dict.h/dictht结构定义：  
```C
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值，总是等于size-1
    unsigned long sizemask;
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;
```
table属性是一个数组，数组中的每一个元素都是指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。  

#### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：  
```C
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```
key属性保存着键值对中的键；  
v属性保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者可以是一个int64_t整数；  
next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突的问题。

#### 4.1.3 字典
Redis中的字典由dict.h/dict结构表示：  
```Ctypedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dict ht[2];
    // rehash索引
    // 当rehash不在进行时，值为-1
    int trehashidx;
} dict;
```
type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同类型特定函数。  
privdata属性则保存了需要传给那些类型特定函数的可选参数。  
```C
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction) (const void *key);
    // 复制键的函数
    void *(*keyDup) (void *privdata, const void *key);
    // 复制值的函数
    void *(valDup) (void *privdata, const void *obj);
    // 对比键的函数
    int (*keyCompare) (void *privdata, const void *key1, const void *key2);
    // 销毁键的函数
    void (*keyDestructor) (void privdata, void *key);
    // 销毁值的函数
    void (*valDestructor) (void *privdata, void *obj);
} dictType;
```
ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]表，ht[1]表只会在ht[0]进行rehash时使用。  
rehashidx记录了rehash目前的进度，如果目前没有在进行rehash，那么他的值为-1。

### 4.2 哈希算法
当要将一个新的键值对添加到字典里面，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

### 4.3 解决键冲突
当有两个以上的键被分配到哈希表数组的同一个索引上面时，我们成这些键发生了冲突。  
Redis的哈希表使用链地址法来解决键冲突，为了考虑速度，程序总是将新节点添加到链表的表头位置。

### 4.4 rehash
当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。  
扩展和收缩哈希表的工作可以通过执行rehash操作来完成，Redis对字典的哈希表执行rehash的步骤如下：  
1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（即ht[0].used属性的值）；  
    如果执行的时扩展的操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的n次幂；  
    如果执行的时收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次幂。  
2. 将保存再ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上；  
3. 当ht[0]包含的所有键值对都迁移到ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。  

### 4.5 渐进式rehash
rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式的完成。  
因为当键值对的数量过大时，要一次性将所有键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。  
渐进式rehash步骤：  
1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；  
2. 在字典中维持一个索引计数器变量rehashidx，并将他的值设置为0，表示rehash工作正是开始；  
3. 在rehash期间，每次对字典进行增删改查操作时，程序除了执行指定操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当
rehash工作完成之后，程序将rehashidx属性的值加一；  
4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx设置为-1，表示rehash操作完成。  
由于在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新操作会在两个哈希表上进行。  
例如，要在字典中查找一个键的话，会先查ht[0]，没找到再去查ht[1]。  
增加键值对只保存到ht[1],这一措施保证ht[0]的键值对数量只减不增，并随着rehash执行而最终变成空表。  

## 第五章 跳跃表
跳跃表是一种有序数据结构，他通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
跳跃表支持平均O(logn)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
如果一个有序集合包含的元素数量比较多，或者有序集合中元素的成员是比较长的字符串时，Redis会使用跳跃表来作为有序集合键的底层实现。
Redis只在两个地方用到跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。
### 5.1 跳跃表的实现
Redis跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，zskiplistNode用于表示跳跃表节点，zskiplist则保存跳跃表节点的相关
信息，如节点数量等。
zskiplist结构的属性：  
1.header：指向跳跃表的表头节点；  
2.tail：指向跳跃表的表尾节点；  
3.level：记录目前跳跃表内，层数最大的哪个节点的层数（表头节点的层数不计算在内）；  
4.length：记录跳跃表的长度，也就是跳跃表目前包含节点的数量（表头节点不计算在内）。  
#### 5.1.1 跳跃表节点
跳跃表节点由redis.h/zskiplistNode结构定义：
```C
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```
1、层  
跳跃表的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序就可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，
访问其他节点的速度就越快。  
每次创建一个新跳跃表节点的时候，程序都会根据幂次定律（越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。
2、前进指针  
每一层都有一个指向表尾方向的前进指针，level[i].forward属性，用于从表头向表尾访问节点。  
3、跨度   
层的跨度用于记录两个节点之间的距离：  
两个节点之间的跨度越大，他们相距越远；  
指向null的所有前进指针的跨度为0，因为他们没有连向任何节点。  
跨度是用来计算排位的，在查找某个节点的过程中，将沿途访问过的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位。  
4、后退指针  
用于从表尾向表头访问节点，跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。  
5、分值和成员  
节点的分值是一个double类型的数，跳跃表中的所有节点都按分值从小到大排序。  
节点的成员对象是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。  
在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序。

#### 5.1.2 跳跃表
仅靠多个跳跃表节点就可以组成一个跳跃表，但通过使用一个zskiplist结构来持有这些节点，程序可以更方便的对整个跳跃表进行处理。  
zskiplist结构的定义如下：
```C
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header,*tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```

### 第六章 整数集合
整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素并且这个元素集合的数量不多时，Redis就会使用整数集合作为集合键的底层实现。

#### 6.1 整数集合的实现
整数集合可以保存类型为int16_t、int32_t、int64_t的整数值，每个intset.h/inset结构表示一个整数集合：
```C
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```
contents数组是整数集合的底层实现，整数集合的每个元素都是contents数组的一个数据项，各个项在数组中按值的大小从小到大有序的排列，并且不包含重复项。
length属性记录了整数集合包含的元素数量，即contents数组的长度。
contents虽然是int8_t类型，但实际上数组并不保存int8_t类型的值，真正的类型取决于encoding属性的值：
#### 6.2 升级
每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加进去。
升级整数集合并添加新元素共分为三部进行：  
1、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间；  
2、将底层数组现有的所有元素都转化为与新元素相同的类型，并将类型转换后的元素放置到正确的位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性。  
3、将新元素添加到底层数组里面。  

#### 6.3 升级的好处
##### 6.3.1 提升灵活性
因为C语言时静态类型语言，为了避免类型错误，我们通常不会讲两种不同类型的值放在同一个数据结构里面。  
通过升级底层数组来适应新元素，而不必担心出现类型错误，这种做法非常灵活。  
##### 6.3.2 节约内存
当然我们可以直接使用int64_t类型作为整数集合的底层实现，不过这样会出现浪费内存的情况。
#### 6.4 降级
整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 第七章 压缩列表
压缩列表ziplist是列表键和哈希键的底层实现之一。
当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么即使长度比较短的字符串，那么就会使用压缩列表来做列表键的底层实现。
另外，当一个哈希键只包含少量键值对，且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么就会使用压缩列表来作哈希键的底层实现。
#### 7.1 压缩列表的构成
压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节
数组或者一个整数值。

### 第八章 对象
Redis并没有直接使用SDS、双端链表、字典、压缩列表、整数集合等数据结构，而是基于这些数据结构，创建了一个对象系统，这个系统包含字符串对象、列表对象、
哈希对象、集合对象、有序集合对象。

#### 8.1 对象的类型和编码
Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），一个
对象用作键值对的值（值对象）。
Redis中的每个对象都由一个redisObject结构表示：
```C
    typedef struct redisObject {
        // 类型
        unsigned type:4;
        // 编码
        unsigned encoding:4;
        // 指向底层实现数据结构的指针
        void *ptr;
        // ...
    } robj;
```

##### 8.1.1 类型
对象的type属性记录了对象的类型，他的值可以是REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET.
对于Redis保存的键值对来说，键总是一个字符串对象，而值可以是其他对象。因此：
当我们称呼一个数据库键为“字符串键”时，我们指的是，这个数据库键所对应的值为字符串对象；
当我们称呼一个数据库键位“列表键”时，我们指的是，这个数据库键所对应的值为列表对象；
以此类推。

##### 8.1.2 编码和底层实现
对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。对象的编码：

|编码常量|编码所对应的底层数据结构|
|-|-|
|REDIS_ENCODING_INT|long类型的整数|
|REDIS_ENCODING_EMBSTR|embstr编码的简单动态字符串|
|REDIS_ENCODING_RAW|简单动态字符串|
|REDIS_ENCODING_HT|字典|
|REDIS_ENCODING_LINKEDLIST|双端链表|
|REDIS_ENCODING_ZIPLIST|压缩列表|
|REDIS_ENCODING_INTSET|整数集合|
|REDIS_ENCODING_SKIPLIST|跳表|

每种类型的底层实现都至少使用了两种不同的编码，就是说同样的类型有不同的底层实现？不同类型的编码的对象：

|类型|编码|对象|
|-|-|-|
|REDIS_STRING|REDIS_ENCODING_INT|使用整数值实现的字符串对象|
|REDIS_STRING|REDIS_ENCODING_EMBSTR|使用embstr编码的简单动态字符串实现的字符串对象|
|REDIS_STRING|REDIS_ENCODING_RAW|使用简单动态字符串实现的字符串对象|
|REDIS_LIST|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的列表对象|
|REDIS_LIST|REDIS_ENCODING_LINKEDLIST|使用双端链表实现的列表对象|
|REDIS_HASH|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的哈希对象|
|REDIS_HASH|REDIS_ENCODING_HT|使用字典实现的哈希对象|
|REDIS_SET|REDIS_ENCODING_INTSET|使用整数集合实现的集合对象|
|REDIS_SET|REDIS_ENCODING_HT|使用字典实现的集合对象|
|REDIS_ZSET|REDIS_ENCODING_ZIPLIST|使用压缩列表实现的有序集合对象|
|REDIS_ZSET|REDIS_ENCODING_SKIPLIST|使用跳跃表实现的有序集合对象|

使用OBJECT ENCODING 键的命令，可以查看一个数据库键的值对象的编码。
通过encoding属性来设定对象所使用的编码，而不是特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为可以根据
不同使用场景为一个对象设置不同的编码，从而优化对象在某一场景下的效率。
例如，在列表对象包含的元素较少时，redis使用压缩列表作为列表对象的底层实现：  
1、因为压缩列表比起双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；  
2、随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存  
大量元素的双端链表上。

#### 8.2 字符串对象
字符串对象的编码可以是int、raw或者embstr。  
如果一个字符串对象保存的时整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面
（将void*转化为long）并将字符串对象的编码设置为int。  
如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于39字节，那么字符串对象将使用一个简单动态字符串来保存这个字符串值，
并将对象的编码设置为raw。  
如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。  
embstr编码时专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都是用redisObject结构和sdshdr结构来表示字符串对象，  
但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr则通过调用一次内存分配函数来分配一块连续的空间，  
空间中一次包含redisObject结构和sdshdr结构。  
embstr编码的字符串对象在执行命令时，产生的效果和raw编码的效果一样，但使用embstr编码的字符串对象来保存短字符串有以下好处；  
1、embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次；  
2、释放embstr编码的字符串对象只需要调用一次内存释放函数；  
3、因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的能够更好的利用缓存带来的优势。  
注意：可以用long double类型表示的浮点数在redis中也是作为字符串值保存的，在有需要的时候，会将字符串对象值转化为浮点数值执行操作。

##### 8.2.1 编码的转换
int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码。
对于int编码来说，如果我们执行了一些命令，是的这个对象值不再是整数值，而是一个字符串值，那么字符串对象的编码将变为raw。
**因为redis没有为embstr编码编写任何相应的修改程序（只有int编码金额raw编码有这些程序），所以embstr编码的字符串对象实际上是只读的。
当我们对embstr编码的字符串对象执行任何修改命令时，都会先转化成raw编码，然后执行修改命令。**

##### 8.2.2 字符串命令的实现
表格待补充

#### 8.3 列表对象
列表对象的编码可以是ziplist或者linkedlist。

##### 8.3.1 编码转换
当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：  
1、列表对象保存的所有字符串元素的长度都小于64字节；  
2、列表对象保存的元素数量小于512个。  
不能满足这两个条件的列表对象需要使用linkedlist编码。  
注意：以上两个条件的上限值是可以修改的，具体查看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。

##### 8.3.2 列表命令的实现
表格待补充

#### 8.4 哈希对象
哈希对象的编码可以是ziplist或者hashtable。
ziplit编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后
再将保存了值的压缩列表节点推入到压缩列表表尾，因此：  
1、保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；  
2、先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。  
hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：  
1、字典的每个键都是一个字符串对象，对象中保存了键值对的键；  
2、字典中每个值都是一个字符串对象，对象中保存了键值对的值；  
 
 ##### 8.4.1 编码转换
 当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：  
 1、哈希对象保存的所有键值对的键和值的字符串长度小于64字节；  
 2、哈希对象保存的键值对数量小于512个；  
 不能满足这两个条件的哈希对象需要使用hashtable编码。  
 注意：以上两个条件的上限值是可以修改的，具体查看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。
 
 ##### 8.4.2 哈希命令的实现
 表格待补充
 
 #### 8.5 集合对象
 集合对象的编码可以是intset或者hashtable。  
 intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。  
 
 ##### 8.5.1 编码转换
当集合对象可以同时满足以下两个条件时，对象使用intset编码：  
1、当集合对象保存的所有元素都是整数值；  
2、当集合对象保存的元素数量不超过512个；  
不能满足这两个条件的集合对象需要使用hashtable编码。  
注意：第二个条件的上限值时可以修改的，具体请看配置文件中关于set-max-intset-entries选项的说明。

##### 8.5.2 集合命令的实现
表格待补充

#### 8.6 有序集合对象
有序集合的编码可以是ziplist或者skiplist。  
ziplist编码的有序集合使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，
第二个节点则保存元素的分值。  
压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在紧靠表头的位置，分值较大的元素被放在紧靠表尾的位置。  
skiplist编码的有序集合使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：
```C
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```
zset中zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，
而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，，程序可以对有序集合进行范围型操作。  
除此之外，zset结构中的dict字典为有序集合创造了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了
元素的成员，字典的值保存了元素的分值。通过这个字典，程序可以用O（1）复杂度查找给定成员的分值。  
有序集合每个元素的成员都是一个字符串对象，每个元素的分值都是一个double类型的浮点数。值得一提的是，虽然zset结构同时使用跳跃表
和字典来保存有序集合中的元素，但这两种数据结构都会通过指针的方式来共享相同元素的成员和分值，所以同时使用跳跃表和字典不会产生任
何重复成员或者分值，也不会因此浪费额外的内存。  
```
为什么有序集合需要同时使用跳跃表和字典来实现呢？
    理论上，有序集合可以单独使用字典或者跳跃表的其中一种来实现，但无论单独使用哪种结构，在性能上对比起同时使用字典和跳跃表都会
有所降低。
```

##### 8.6.1 编码的转换
当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：  
1、有序集合保存的元素数量小于128；  
2、有序集合保存的所有元素成员的长度都小于64字节；  
不能满足以上两个条件的有序集合对象将使用skiplist编码。  
注意：以上两个条件的上限值是可以修改的，具体请看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。

##### 8.6.2 有序集合命令的实现
表格待补充

#### 8.7 类型检查与命令多态
redis中用于操作键的命令基本上可以分为两种类型。  
其中一种命令可以对任何类型的键执行，比如说DEL命令。  
另一种命令只能对特定类型的键执行，比如说：  
1、SET、GET、APPEND、STRLEN等命令只能对字符串键使用；  
2、HDEL、HSET、HGET、HLEN等命令只能对哈希键使用；  
3、RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键使用；  
4、SADD、SPOP、SINTER、SCARD等命令只能对集合键使用；  
5、ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键使用。  

##### 8.7.1 类型检查的实现
redis会先检查输入的类型是否正确，然后再决定是否执行给定的命令。  
类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：  
1、在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就执行命令；  
2、否则服务器将拒绝执行命令，并项客户端返回一个类型错误。  

#### 8.8 内存回收
因为C语言并不具备自动内存回收功能，所以redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，，通过这一机制，
程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。  
每个对象的引用计数信息由redisObject对象结构的refcount属性记录。  
对象的引用计数信息会跟随着对象的使用者状态而不断变化：  
1、在创建一个新对象时，引用计数的值会被初始化为1；  
2、当对象被一个新程序使用时，引用计数值会加一；  
3、当对象不再被一个程序使用时，引用计数会减一；  
4、当对象的引用计数值变为0时，对象所占用的内存会被释放。  

#### 8.9 对象共享
除了用于实现引用计数内存回收机制外，对象的引用计数属性还带有对象共享的作用。例如：  
假设键A创建了一个包含整数值100的字符串对象作为值对象，如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，
那么服务器有两种做法：  
1、为键B新创建一个包含整数值100的字符串对象；  
2、让键A和键B共享同一个字符串对象；  
显然第二种方法更节约内存。在redis中让多个键共享同一个值对象需要执行两个步骤：  
1、将数据库键的值指针指向一个现有的值对象；  
2、将被共享的值对象的引用计数加一。  
注意：创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS常量来修改。  

#### 8.10 对象的空转时长
redis的redisObject结构还有一个lru属性，该属性记录了对象最后一次被命令程序访问的时间。  
OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。  
注意：OBJECT IDLETIME命令命令在访问键的值对象时，不会修改lru属性。  
键的空转时长的另一个作用时，如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，
那么当服务器占用的内存数超过了maxmemory设置的上限，空转时长较高的那部分键会优先被服务器释放，从而回收内存。


### 第九章 数据库
#### 9.1 服务器中的数据库
redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，
每个redisDb结构代表一个数据库：  
```C
struct redisServer {
    // ...
    // 一个数组，保存着服务器中的所有数据库
    redisDb *db;
    //...
};
```
在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库：  
```C
struct redisServer {
    // ...
    // 服务器的数据库数量
    int dbnum;
    // ...
};
```
dbnum属性的值由服务器配置的database选项决定的，默认为16。

#### 9.2 切换数据库
每个redis客户端都有自己的目标数据库，每当客户端执行数据库命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。  
默认情况下，redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。  
在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：  
```C
typedef struct redisClient {
    // ...
    // 记录客户端当前正在使用的数据库
    redisDb *db;
    // ...
} redisClient;
```

#### 9.3 数据库键空间
redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了
数据库中所有键值对，我们将这个字典成为键空间：  
```C
typedef struct redisDb {
    // ...
    // 数据库键空间，保存着数据库中的所有键值对
    dict * dict;
    // ...
} redisDb;
```
键空间和用户所见的数据库是直接对应的：  
1、键空间的键也就是数据库的键，每个键都是一个字符串对象；  
2、键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希对象、集合对象和有序集合对象中的任意一种redis对象。  

##### 9.3.1 添加新键
添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面。

##### 9.3.2 删除键
删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。

##### 9.3.3 更新键
对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有不同。

##### 9.3.4 对键取值
对一个数据库键取值，实际上就是在键空间中取出键所对应的值对象。

##### 9.3.5 其他键空间操作
除了增删改查，还有很多针对数据库本身的redis命令，也是通过对键空间进行处理完成的。  
比如，用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对实现的。  

##### 9.3.6 读写键空间时的维护操作
当使用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作：  
1、在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器键空间命中（hit）次数和不命中（miss）
次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_miss属性中查看。  
2、在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime<key>
命令可以查看键key的闲置时间。  
3、如果服务器在读取一个键时发现该键已经能过期，那么服务器会先删除这个过期键，然后再执行余下的操作。  
4、如果有客户端使用WAWTCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏，从而让事务程序注意到
这个键已经被修改过。  
5、服务器每次修改一个键之后，都会对脏键计数器加一，这个计数器会触发服务器的持久化以及复制操作。  
6、如果服务器开启了数据库通知功能，那么在对键修改后，服务器将按配置发送相应的数据库通知。

#### 9.4 设置键的生存时间或过期时间
通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，在经过指定时间后，服务器会自动
删除生存时间为0的键。  

##### 9.4.1 设置值过期时间
redis有四个不同的命令可以用于设置键的生存时间或过期时间：
1、EXPIRE(key)<ttl>命令用于将键key的生存时间设置为ttl秒；  
2、PEXPIRE(key)<ttl>命令用于将键key的生存时间设置为ttl毫秒；  
3、EXPIREAT(key)<timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳；  
4、PEXPIREAT(key)<timestamp>命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。  

##### 9.4.2 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：
1、过期字典的键是一个指针，这个指针指向键空间中的某个键对象，也即是某个数据库键；  
2、过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。  
```C
typedef struct redisDb {
    // ...
    // 过期字典，保存着键的过期时间
    dict *expires;
    // ...
} redisDb;
```

##### 9.4.3 移除过期时间
PERSIST命令可以移除一个键的过期时间。

##### 9.4.4 计算并返回剩余生存时间
TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒返回键的剩余生存时间。

##### 9.4.5 过期键的判定
通过过期字典，程序可以用以下步骤检查一个给定键是否过期：  
1、检查给定键是否存在与过期字典中，如果存在则取得键的过期时间；  
2、检查当前UNIX时间戳是否大于键的过期时间；如果是则已过期，否则未过期。

#### 9.5 过期键删除策略
如果一个键过期了，什么时候会被删除呢？有三种删除策略：定时删除、惰性删除、定期删除。

##### 9.5.1 定时删除
定时删除是对内存最友好的，通过使用定时器，定时删除可以保证过期键会尽可能快被删除，并释放过期键占用的内存。  
另一方面，定时删除的缺点是对CPU不友好，在过期键比较多的情况下，删除过期键这一操作可能会占用相当一部分CPU时间，
在内存不紧张但CPU紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务i其的响应时间和吞吐量造成影响。  
除此之外，创建一个定时器需要用到redis服务器中的时间事件，而当前时间事件的实现方式为无序链表，查找一个时间的时间复杂度
为O（N）并不能高效地处理大量时间事件。

##### 9.5.2 惰性删除
惰性删除对CPU来说是最友好的，程序只会在取出键的时候才对键进行过期检查，并且删除的目标仅限于当前处理的键，不会再其他无
关的键上花费任何CPU时间。  
缺点是对内存不友好，如果一个键已经过期，而又不被删除，会一直占用内存。

##### 9.5.3 定期删除
定时删除是前面两种策略的整合折中：  
1、每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少操作对CPU时间的影响；  
2、初次之外，通过定期删除过期键，定期删除策略有效的减少了因为过期键而带来的内存浪费。  

#### 9.6 redis的过期键删除策略
redis服务器实际使用的是惰性删除和定期删除两种策略，通过两种策略配合，可以很好的在CPU和内存之间取得平衡。

#### 9.7 AOF、RDB和复制功能对过期键的处理
##### 9.7.1 生成RDB文件
在执行SAVE命令或者BGSAVE命令创建一个性的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新的RDB文件中。

##### 9.7.2 载入RDB文件
在启动redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：  
1、如果服务器以主服务器模式运行，那么载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库，过期键则
会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。  
2、如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为
主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会有影响。

##### 9.7.3 AOF文件写入
当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但他还没有被惰性删除或者定期删除，那么AOF文件不会因为这个
过期键产生任何影响。  
当过期键被惰性删除或者定期删除后，程序会向AOF追加一条del命令，来显示地记录该键已被删除。  

##### 9.7.4 AOF重写
和生成RDB文件类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

##### 9.7.5 复制
当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：  
1、主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键；  
2、从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期键一个处理。  
3、从服务器只有在接到主服务器发来的del命令后，才会删除过期键。  

#### 9.8 数据库通知
数据库通知时redis 2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及
数据库中命令的执行情况。

### 第十章 RDB持久化
redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便
起见，我们将服务器中的非空数据库以及他们的键值对统称为数据库状态。  
redis是内存数据库，一旦服务器进程退出，服务器中的数据库状态也会消失不见。为了解决在这个问题，redis提供了RDB持久化功
能，可以将redis在内存中的数据库状态保存到磁盘里，避免数据意外丢失。  
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到RDB文件中。  
RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。  

#### 10.1 RDB文件的创建与载入
有两个redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。
save命令会阻塞redis服务器进程，直到RDB文件创建完成，在服务器进程阻塞期间，服务器不能处理任何命令请求。  
bgsave命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。  
RDB文件的载入工作是在服务器启动时自动执行的，redis并没有专门的RDB文件载入命令，只要redis服务器在启动时检测到RDB文件
存在，就会自动载入。  
另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：  
1、如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。  
2、只有在AOF持久化功能处于关闭状态时，才会使用RDB文件来还原数据库状态。  

##### 10.1.1 RDB文件载入时的服务器状态
RDB文件载入期间，服务器会一直处于阻塞状态，直到载入工作完成。

#### 10.2 自动间隔性保存
因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间
自动执行一次BGSAVE命令。  
用户可以通过save选项设置多个保存条件，只要其中一个条件满足，服务器就会执行BGSAVE命令。例如我们给服务器提供以下配置：
save 900 1  
save 300 10  
save 60 10000  
那么只要满足任意一个条件，命令就会执行：
1、服务器在900秒内，对数据库进行了至少一次修改。  
2、服务器在300秒内，对数据库进行了至少十次修改。  
3、服务器在60秒内，对数据库进行了至少10000修改。  

##### 10.2.1 设置保存条件
当redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么默认的配置：
save 900 1  
save 300 10  
save 60 10000  
服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：  
```C
struct redisServer {
    // ...
    // 记录了保存条件的数组
    struct saveparam *saveparams;
    // ...
};
```
saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件：  
```C
struct saveparam {
    // 秒数
    time_t  seconds;
    // 修改数
    int changes;
};
```

##### 10.2.2 dirty计数器和lastsave属性
除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：  
1、dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次
修改（保存写入、删除、更新等操作）。  
2、lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

##### 10.2.3 检查保存条件是否满足
redis的服务器周期性执行函数serverCron默认每隔10秒执行一次，该函数用于对正在运行的服务器进行维护，他的其中一项工作就是
检查save选项所设置的保存条件是否已经满足。

#### 10.3 RDB文件结构
一个完整的RDB文件结构：REDIS,db_version,databases,EOF,check_sum。  
注意：为了方便区分变量、数据、常量，用全大写单词表示常量，用全小写单词表示变量和数据。  
RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着"REDIS"5个字符。通过这五个字符，程序可以在载入文件时，快速检查
所载入的文件是否为RDB文件。  
db_version长度为4字节，他的值是一个字符串表示的整数，记录了RDB文件的版本号，比如“006”就代表RDB文件为第六版。  
database部分包含着零个或者多个数据库，以及各个数据库中的键值对数据：  
1、如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。  
2、如果服务器的数据库状态为非空（至少有一个数据库非空），那么这个部分也为非空。根据数据库所保存键值对的数量、类型和内容不容，
这个部分的长度也会有所不同。  
EOF常量的长度为1字节，这个常量标志着RDB文件正文的结束，当读入程序遇到这个值的时候，他知道所有数据库的所有键值对都已经载入完毕了。  
check_sum是一个8字节的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容
计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，一次来检查RDB文件是否
出错或者损坏。  

##### 10.3.1 databases部分
每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。  
SELECTDB常量的长度为1字节，当程序遇到这个值的时候，他知道接下来要读入的将是一个数据库号码。  
db_number保存着一个数据库号码，根据号码大小的不同，这个部分的长度可以是1字节、2字节、5字节。当程序读入db_number部分之后，
服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。**—— 程序怎么知道这里应该读几个字节？**
key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对
的数量、类型、内容以及是否有过期键等条件不同，该部分长度也会有所不同。  

##### 10.3.2 key_value_pairs部分
RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，也会被保存在内。  
不带过期时间的键值对在RDB文件中由TYPE、key、VALUE三部分组成。  
TYPE记录了value的类型，长度为1字节，值可以是以下的常量中的一个：  
1、REDIS_RDB_TYPE_STRING  
2、REDIS_RDB_TYPE_LIST  
3、REDIS_RDB_TYPR_SET
4、REDIS_RDB_TYPE_ZSET
5、REDIS_RDB_TYPR_HASH
6、REDIS_RDB_TYPE_LIST_ZIPLIST
7、REDIS_RDB_TYPE_SET_INSET
8、REDIS_RDB_TYPE_ZET_ZIPLIST
9、REDIS_RDB_TYPE_HASH_ZIPLIST  
每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对时，会根据TYPE的值决定如何读入和解释value的数据。  
key和value分别保存了键值对的键对象和值对象：  
1、其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度不同，key的长度不同。  
2、根据TYPE类型不同，以及保存内容长度的不同，保存value的结构和长度也会不同。  
带有过期时间的键值对在RDB文件中保存结构为：EXPIRETIME_MS、ms、TYPE、key、value。  
EXPITETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。  
ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。  

##### 10.3.3 value的编码
类型编码参见第八章  
1、字符串对象  
TYPE值为REDIS_RDB_TYPE_STRING，那么value保存的是字符串，字符串对象的编码格式可一个REDIS_ENCONDING_INT或者REDIS_ENCODING_RAW。  
如果字符串对象的编码是REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。这种编码将以ENCODING、integer的结构保存。  
其中ENCODING的值可以是REDIS_RDB_INT8、REDIS_RDB_INT16、REDIS_RDB_INT32之一，它们代表用8位、16位、32位来保存整数值integer。  
如果字符串编码为REDIS_ENCODING_RAW，说明对象所保存的是字符串，根据字符串长度不同，有压缩和不压缩两种方式来保存：  
1）如果字符串的长度小于20字节，那么字符串被原样保存。  
2）如果字符串长度大于20字节，那么字符串被压缩保存。  
注意：以上两个条件是在假设服务器打开了RDB文件压缩功能的情况下进行的，如果服务器关闭了RDB文件压缩功能，那么RDB程序总以无压缩的
方式保存字符串值。  
对于未被压缩的字符串将以len、string的结构来保存。其中len保存字符串的长度，string保存字符串本身。  
对于压缩后的字符串，将以REDIS_RDB_ENC_LZF、compressed_len、origin_len、compressed_string结构保存。  
其中REDIS_RDB_ENC_LZF常量标志着字符串已经被LZF算法压缩过了，程序碰到这个常量后，会对字符串进行解压缩。  
compressed_len记录的是字符串压缩之后的长度，origin记录的是字符串原来的长度，compressed_string记录的是被压缩的字符串。  
2、列表对象  
如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存
的结构为：list_length、item1、item2、item3...  
list_length记录了列表的长度，表示列表保存了多少项（item）。而每个item都是一个字符串对象。  
3、集合对象  
如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构
为set_size、elem1、elem2...
其中，set_size是集合的大小，记录了集合保存了多少元素，读入程序可以通过这个大小知道自己应该读入多少个集合元素。  
4、哈希表对象  
如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件结构为
hash_size、key_value_pair1、key_value_pair2...  
5、有序集合对象  
如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合，RDB文件保存
的结构为sorted_set_size、elem1、elem2...  
6、INTSET编码的集合  
如果TYPE的值为REDIS_RDB_TYPE_INTSET，那么value保存的就是一个整数集合对象，RDB保存这种对象的方法是，先将整数集合转换为
字符串对象，然后将这个字符串保存到RDB文件里面。  
如果程序在读入RDB文件的过程中 ，碰到由整数集合对象转换成的字符串对象，，会根据TYPE值的指示，先读入字符串对象，再将字符串
转换为原来的整数集合对象。  
7、ZIPLIST编码的列表、哈希表或者有序集合  
如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST、REDIS_RDB_TYPE_ZSEP_ZIPLIST，value
保存的就是一个压缩列表对象，RDB文件中保存的结构方法是：  
将压缩列表保存转换成一个字符串对象，将字符串对象保存到RDB文件中。解析则反过来。  

#### 10.4 分析RDB文件  
我们使用od命令来分析Redis服务器产生的RDB文件，该命令可以用给定的格式转存并打印输入文件。

### 第十一章 AOF持久化
除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB通过保存数据库中的键值对来记录数据库状态不同，
AOF是通过保存Redis服务器所执行的写命令来记录数据库状态的。  
被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式，所以我们可以直接打开一个AOF
文件，观察里面的内容。  
在服务器启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。  

#### 11.1 AOF持久化的实现
AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。  

##### 11.1.1 命令追加
当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的命令追加到服务器状态的aof_buf缓冲区的末尾：  
```C
strcut redisServer {
    // ...
    // AOF缓冲区
    sds aof_buf
    // ...
};
```

##### 11.1.2 AOF文件的写入与同步
Redis的服务器进程就是一个事件循环（loop）,这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件
则负责执行像serverCron函数这样需要定时运行的函数。  
因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区，所以在服务器每次结束一个事件循环之前，它都会调
用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。  
flushAppendOnlyFile函数的行为由服务器配置之的appendfsync选项的值来决定，各个不同值产生的行为如下表：  
|appendfsync的值|flushAppendOnlyFile函数行为|
|-|-|
|always|将aof_buf缓冲区中所有内容写入并同步到AOF文件|
|everysec|将aof_buf缓冲区的所有内容写入到AOF文件，如果上次同步AOF文件的事件距离现在超过一秒，那么再次对AOF文件进行同步，
并且这个同步操作是由一个线程专门负责执行的|
|no|将aof_buf缓冲区的所有内容写入到AOF文件，但不进行同步，何时进行同步由操作系统决定|

文件的写入和同步  
为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在
一个内存缓冲区里面，等到缓冲区的空间被填满，或者超过了指定时间，才真正将缓冲区中的数据写入到磁盘。  
这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么缓冲区的数据将会丢失。  
为此，系统提供了fsync和fdatasync两个同步函数，他们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保数据正确性。  

#### 11.2 AOF文件的载入和数据还原
服务器只需要读入并重新执行一遍AOF文件保存的命令，就可以还原数据库状态。

#### 11.3 AOF重写
因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积
也会越来越大，如果不加以控制，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，还原
数据需要的时间也就越久。  
为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写功能。通过该功能，Redis服务器可以创建一个新的AOF文件来代替现有的文件
，新旧两个文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以体积更小。

##### 11.3.1 AOF文件重写实现
虽然Redis将生成新AOF文件替换旧AOF文件的功能命令为“AOF文件重写”，但实际上AOF文件重写并不需要对旧的AOF文件进行读取、分析和
写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。  
假设我们执行了6个命令，每个命令都是向同一个list中添加一个元素，那么我们可以读取数据库中list的值，并将6个元素的添加放到一条
命令里面，这样可以将6条命令减少成1条。  
如果一条命令长度太长，重写程序将使用多条命令来记录。
redis使用aof_rewrite函数进行重写。

##### 11.3.2 AOF后台重写
aof_rewrite函数会进行大量写入的操作，所有调用这个函数的线程将被长时间阻塞，因为redis服务器使用单线程来处理命令请求，所以
如果由服务器直接调用重写函数，那么在AOF文件重写期间，服务器将无法处理客户端发来的命令。  
所以Redis将AOF从写程序放到子进程里执行，这样可以达到两个目的：  
1、子进程进行AOF文件重写期间，服务器进程（父进程）可以继续处理命令。  
2、子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。  
不过，使用子进程也有一个问题需要解决，因为子进程在进行重写的时候，父进程也在处理请求，所以会有当前数据库状态和重写后的AOF文件
数据库状态不一样的情况发生。  
为了解决这种不一致，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写
命令之后，同时将这个命令发送给AOF缓冲区和AOF重写缓冲区，也就是说，在子进程执行AOF重写期间，服务器进程需要执行三个工作：  
1、执行客户端发来的命令。  
2、将执行后的写命令追加到AOF缓冲区。  
3、将执行后的写命令追加到AOF重写缓冲区。  
这样可以保证：  
1、AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有的AOF文件的处理工作正常进行。  
2、从创建子进程开始，服务器的所有写命令会被记录到AOF重写缓冲区。  

### 第十二章
Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：  
1、文件事件：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器
与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。  
2、时间事件：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。 

#### 12.1 文件事件
Redis基于Reactor模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器：  
1、文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。  
2、当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用
套接字之前关联好的事件处理器来处理这些事件。  
虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件既实现了高性能的网络通信模型，又可以
很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，着保持了Redis内部单线程设计的简单性。  

##### 12.1.1 文件事件处理器的构成
文件事件处理器由套接字、IO多路复用程序、文件事件分派器以及事件处理器构成。  
文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件，因为一个服务器
通常会连接多个套接字，所以多个文件事件有可能会并发地出现。  
IO多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。  
尽管多个文件事件可能会并发出现，但IO多路复用程序总是会将所有产生的套接字都放入到一个队列里面，然后通过这个队列，以有序、同步、
每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），
IO多路复用程序才会继续向文件事件分派器传送下一个套接字。  
文件事件分派器接受IO多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。  
服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器时一个个函数，他们定义了某个事件发生时，服务器应该执行的动作。

##### 12.1.2 IO多路复用程序的实现
Redis的IO多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些IO多路复用函数库来实现的，每个IO多路
服用库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c等。  
因为Redis为每个IO多路复用函数库都实现了相同的API，所以IO多路复用程序的底层实现是可以互换的。  

##### 12.1.3 事件的类型
IO多路复用程序可以监听多个套接字ae.h/AE_READABLE事件和ae.h/AE_WRITEABLE事件，这两类事件和套接字操作之间的对应关系如下：  
1、当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答套接字出现时（客户端对服务器的监听
套接字执行connect操作），套接字产生AE_READABLE事件。  
2、当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITEABLE事件。  
IO多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITEABLE事件，如果一个套接字同时产生了这两个事件，那么文件
事件分派器会优先处理AE_READABLE事件，等处理完后，才处理AE_WRITEABLE事件。也就是说，如果一个套接字又可读又可写的话，那么
服务器将先读套接字，后写套接字。

##### 12.1.5 文件事件的处理器
Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：  
1、为了连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。  
2、为了接收客户端传来的命令请求，服务器要为客户端套接字命令关联命令请求处理器。  
3、为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。  
4、当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。  

#### 12.2 时间事件
Redis的时间事件分为以下两类：  
1、定时事件：让一段程序在指定的时间之后执行一次。  
2、周期性事件：让一段程序每隔指定时间执行一次  
一个时间事件主要由以下三个属性组成：  
1、id：服务器为时间事件创建的全局唯一ID（标识号），ID号按从小到大的顺序递增，新事件的ID比旧事件大。  
2、when：毫秒精度的UNIX时间戳，记录了时间事件的到达时间。  
3、timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。  
一个时间事件是定时事件还是周期事件取决于事件处理器的返回值：  
1、如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件，该事件在达到一次之后就会被删除，之后不再到达。  
2、如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期事件，当一个时间事件到达之后，服务器会根据事件处理器返回的值，
对时间事件的when属性进行更新，让这个事件在一段时间后再次到达，并以这种方式一直更新并运行下去。  

##### 12.2.1 实现
服务器将所有时间时间都放在一个无序链表里面，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的
事件处理器。  
我们说的链表为无序链表不是链表不按ID排序，而是链表不按when属性大小排序，而每次新的事件都会插入到链表头部。  

##### 12.2.2 时间事件应用实例：serverCron函数
持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作由redis.c/serverCron
函数负责执行，它的主要工作包括：  
1、更新服务器的各类统计信息，如时间、内存占用、数据库占用情况的等。  
2、清理数据库中的过期键值对。  
3、关闭和清理连接失效的客户端。  
4、尝试进行AOF或RDB持久化操作。  
5、如果服务器是主服务器，那么对从服务器进行定期同步。  
6、如果处于集群模式，对集群进行定期同步和连接测试。  
Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，serverCron就会执行一次，直到服务器关闭。

#### 12.3 事件的调度与执行
因为服务器中同时存在文件事件和时间事件两种类型，所以服务器必须对着两种事件进行调度，决定何时应该处理文件事件，何时处理时间事件，
以及花多少时间来处理他们等。  
因为文件事件是随机出现的，如果等待并处理完一次文件事件后，仍没有时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件
的不断执行，事件逐渐向时间事件所设置的到达时间逼近，这时服务器就可以开始处理到达的时间事件了。  
对文件事件和时间事件的处理都是同步、有序、原子的执行，服务器不会中途中断事件，也不会对事件进行抢占，因此，不管是文件事件的处理器，
还是时间事件的处理器，都会尽可能减少程序的阻塞时间，并在由需要时主动让出执行权，从而降低造成事件饥饿的可能性。  

### 第十三章 客户端
Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则
接受并处理客户端发送的命令请求，并返回命令回复。  
通过使用IO多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。  
对于每个与服务器进行连接的客户端，服务器都为客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端
当前的状态信息，以及执行相关功能时需要用到的数据结构，包括：  
1、客户端的套接字描述符；  
2、客户端的名字；  
3、客户端的标志值（flag）；  
4、执行客户端正坐在使用的数据库指针，以及该数据库的号码；  
5、客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针；  
6、客户端的输入缓冲区和输出缓冲区；  
7、客户端的复制状态信息，以及进行复制所需的数据结构；  
8、客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构；  
9、客户端的事务状态，以及执行WATCH命令时用到的数据结构；  
10、客户端执行发布与订阅功能时用到的数据结构；  
11、客户端的身份验证标志；  
12、客户端的创建时间，客户端和服务器最后一次通信的时间，和客户端的输出缓冲区大小超出软性限制的时间。  

#### 13.1 客户端属性
客户端状态包含的属性分为两类：  
1、一类时比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都需要用到这些属性；  
2、另一类是和特定功能相关的一些属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及
执行WATCH命令时需要用到的watched_keys属性。  

##### 13.1.1 套接字描述符
客户端状态的fd属性记录了客户端正在使用的套接字描述符，根据客户端类型的不同，fd属性的值可以是-1或者大于-1的整数：  
1、伪客户端的fd属性的值为-1：伪客户端处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接，
自然也不需要记录套接字描述符。

### 第十五章 复制
在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主
服务器，进行复制的服务器为从服务器。  
进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致“，或者简称”一致“。  

#### 15.1 旧版复制功能的现实
Redis的复制功能分为同步和命令传播两个操作：  
1、同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。  
2、命令传播操作则用于在主服务器的数据库状态被修改，导致主服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

##### 15.1.1 同步
当客户端向从服务器发送SALVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作。  
从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令执行步骤：  
1、从服务器向主服务器发送SYNC命令。  
2、收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。  
3、当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE生成的RDB文件发送给从服务器，从服务接收并载入这个RDB文件，将自己的
数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。  
4、主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库的当前状态。  

##### 15.1.2 命令传播
在同步操作执行完毕之后，主从服务器两者的数据库状态将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的
写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。  
为了让主服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致
的那条命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

#### 15.2 旧版复制功能的缺陷
在Redis2.8以前，从服务器对主服务器的复制可以分为以下两种情况：  
1、初次复制；从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同；  
2、断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制。  
对于初次复制，旧版复制功能能够很好的完成任务，但对于断线重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率
却非常低，**因为重连后会发送SYNC命令，相当于初次复制**。

#### 15.3 新版复制功能的实现
为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。
PSYNC命令具有完整重同步和部分重同步两种模式：  
1、完整重同步用于处理初次复制情况，执行步骤和SYNC命令步骤基本一样；  
2、部分重同步用于处理断线重复制情况：当服务器在短线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器断开连接期间执
行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

#### 15.4 部分重同步的实现
部分重同步功能由以下三部分组成：
1、主服务器的复制偏移量和从服务器的复制偏移量；  
2、主服务器的复制积压缓冲区；  
3、服务器的运行ID。  

##### 15.4.1 复制偏移量
执行复制的双方分别会维护一个复制偏移量；  
1、主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N；  
2、从服务器每次收到主服务器传播来的N个字节数据时，就将自己的复制偏移量加上N。  
通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态。

##### 15.4.2 复制积压缓冲区
复制积压缓冲区是由主服务器维护的一个固定长度（超长时队头元素会被弹出，新元素入队）先进先出队列，默认大小为1M。  
当主服务器进行命令传播时，它不仅会将写命令发送给所有服务器，还会将写命令入队到复制积压缓冲区里面。因此，主服务器的复制积压缓冲区
里面会保存着一部分最近传播的命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量，如下表所示； 
|-|-|-|-|-|-|-| 
|偏移量|...|10087|10088|10089|10099|...|
|字节值|...|'*'|3|'s'|'\r'|...|

当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决
定对从服务器执行何种同步操作：
1、如果offset之后的数据仍然存在与复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作；  
2、如果offset之后的数据已经不存在于复制积压缓冲区，那么主服务器将执行完整重同步操作。  
复制积压缓冲区的最小大小可以根据公式 second * write_size_per_second来估算：  
1、second为从服务器断线后重新连接所需的平均时间（以秒计算）。  
2、write_size_per_second是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。  
为了安全起见，可以将复制积压缓冲区的大小设置为2 * second * write_size_per_second，这样可以保证绝大部分断线重连情况都能用
部分重同步来处理。  
复制积压缓冲区大小的修改方法，可以参考配置文件中关于repl-backlog-size的选项说明。

##### 15.4.3 服务器运行ID
1、每个Redis服务器，不论主服务器还是从服务器，都会有自己的运行ID；  
2、运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。  
当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个ID保存起来。  
当从服务器断线重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的ID：  
1、如果保存的ID和当前连接的主服务器运行ID相同，可以尝试部分重同步操作；  
2、否则，需要执行完整重同步操作。  

#### 15.5 PSYNC命令的实现
PSYNC命令的调用方法有两种：  
1、如果从服务器以前没有复制过任务主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器
发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这个时候不可能执行部分重同步）。  
2、如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC <runid> <offset>命令：其中
runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断
因该对从服务器执行哪种同步操作。  
接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种： 
1、如果主服务器返回+FULLRESYNC <runid> <offset>回复，那么表示主服务器将于从服务器执行完整重同步操作：其中runid是这个
主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器
会将这个值作为在自己的初始化偏移量。  
2、如果主服务器返回+CONTINUE回复，表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数
据发送过来就可以了。  
3、如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis2.8，识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并
与主服务器执行完整重同步操作。  

#### 15.6 复制的实现
通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器：  
SLAVEOF <master_ip> <master_port>  
##### 15.6.1 步骤1：设置主服务器的地址和端口
当客户端向从服务器发送SLVAEOF命令时，从服务器首先要做的就是将客户端给定的主服务器ip和端口保存到服务器状态的masterhost和
masterport属性。  
```C
struct redisServer {
    // ...
    // 主服务器地址
    char *masterhost;
    // 主服务器端口
    int masterport;
    // ...
};
```
##### 15.6.2 步骤2：建立套接字连接
