Redis设计与实现
===
目录
---
[第二章 简单动态字符串](#第二章-简单动态字符串)

>[2.1 SDS的定义](#21-SDS的定义)

>[2.2 SDS 与 C 字符串的区别](#22-SDS-与-C-字符串的区别)

>>[2.2.1 常数复杂度获取字符串长度](#221-常数复杂度获取字符串长度)

>>[2.2.2 杜绝缓冲区溢出](#222-杜绝缓冲区溢出)

>>[2.2.3 减少修改字符串时带来的内存重分配次数](#223-减少修改字符串时带来的内存重分配次数)

>>[2.2.4 二进制安全](#224-二进制安全)

[第三章 链表](#第三章-链表)

>[3.1 链表和链表节点的实现](#31-链表和链表节点的实现)

[第四章 字典](#第四章-字典)

>[4.1 字典的实现](#41-字典的实现)

>>[4.1.1 哈希表](#411-哈希表)

>>[4.1.2 哈希表节点](#412-哈希表节点)

>>[4.1.3 字典](#413-字典)

>[4.2 哈希算法](#42-哈希算法)

>[4.3 解决键冲突](#43-解决键冲突)

>[4.4 rehash](#44-rehash)

>[4.5 渐进式rehash](#45-渐进式rehash)

[第五章 跳跃表](#第五章-跳跃表)

## 第二章 简单动态字符串
Redis没有使用C语言传统的字符串（以空字符结尾的字符数组）表示，而是自己构建了一种名为简单动态字符串的类型（simple dynamic string，SDS），并将其作为Redis的默认字符串表示。

### 2.1 SDS的定义
每个sds.h/sdshdr结构表示一个SDS的值：  
```C
struct sdshdr {
    // 记录buf数组中已经使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    car buf[];
}
```
示例，将Redis字符串使用SDS保存，则：  
free属性的值为0，表示这个SDS没有分配任何未使用空间；  
len属性的值为5，表示这个SDS保存了一个五字节长的字符串；  
buf属性是一个char类型的数组，数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's'五个字符，最后一个字节则保存了空的字符串'\0'。  
保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符串到字符串末尾等操作，都是由SDS函数自动完成的。  
遵循这一惯例的好处是，SDS可以直接使用一部分C字符函数库里面的函数。  

### 2.2 SDS 与 C 字符串的区别
#### 2.2.1 常数复杂度获取字符串长度
SDS的len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)。  
设置和更新SDS长度的工作是由SDS API在执行时自动完成的，使用SDS无需进行任何手动修改长度的操作。  

#### 2.2.2 杜绝缓冲区溢出
当SDS API许哟对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才
执行实际的修改操作。  

#### 2.2.3 减少修改字符串时带来的内存重分配次数
如果程序执行增加字符串的操作，那么在执行这个操作之前，需要先通过内存重分配来扩展底层数组的大小，如果忘了这个步骤就会产生缓冲区溢出。  
如果程序执行缩短字符串的操作，那么在执行操作之后，需要通过内存重分配来释放字符串不再使用的那部分空间，如果忘了这个步骤就会产生内存泄漏。  
因为内存重分配设计复杂的算法，并且可能需要执行系统调用，所以他通常是一个比较耗时的操作：  
在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的；  
但是Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的
时间就会占去修改字符串所用时间的一大部分，如果频繁的修改，可能还会对性能造成影响。  
为了避免这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的
字节，而这些字节的数量就由SDS的free属性记录。  
通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。  
1. 空间预分配  
空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会
为SDS分配额外的未使用空间。其中额外分配的未使用空间数量由以下公式决定：
如果对SDS进行修改之后，SDS的长度（len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间；
如果对SDS进行修改之后，SDS的长度将大于1MB，那么程序会分配1MB的未使用空间。
2. 惰性空间释放  
惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free
属性将这些字节的数量记录起来，并等待将来使用。
同时，SDS也提供了相应的API，让我们可以在有需要的时候，真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。

#### 2.2.4 二进制安全
C字符串中的字符必须符合某种编码（如ASCII），并且认为除了字符串的末尾，字符串里面不能包含空字符，否则最先被程序读入的空字符将会被误认为时字符串结尾，
这些限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频等二进制数据。
SDS的API都是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据组任何限制、过滤、或者假设，
写入是什么样，读取时就是什么样。  
这也是我们将SDS的buf属性成为字节数组的原因——Redis不是用这个数组来保存字符，而使用他来保存一系列二进制数据。

## 第三章 链表
链表被广泛用于实现Redis各种功能，比如列表键、发布与订阅、慢查询、监视器等。  
### 3.1 链表和链表节点的实现
每个链表节点使用一个adlist.h/listNode结构来表示：  
```C
typedef struct listNode {
    // 前置节点
    struct listNode * prev;
    // 后置节点
    struct listNode * next;
    // 节点的值
    void * value;
}listNode;
```
虽然仅仅使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：  
```C
typedef struct list {
    listNode * head;
    listNode * tail;
    unsigned long len;
    void * (*dup) (void *ptr);
    void * (*free) (void *ptr);
    int (*match) (void *ptr,void *key);
} list;
```
list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：  
dup函数用于复制链表节点所保存的值；  
free函数用于释放链表节点所保存的值；  
match函数用于对比链表节点所保存的值和另一个输入值是否相等。  
Redis的链表实现的特性可以总结如下：  
双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1);  
无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点；  
带表头指针和表尾指针：获取链表头节点和尾节点的复杂度为O(1)；  
带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，获取节点数量复杂度为O（1）；  
多态：链表节点使用void * 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点设置类型特定函数，所以链表可以用于保存各种类型值。  

## 第四章 字典
字典又称为符号表、关联数组或者映射，是一种用于保存键值对的抽象数据结构。  
### 4.1 字典的实现
Redis使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。  
#### 4.1.1 哈希表
Redis字典所使用的哈希表由dict.h/dictht结构定义：  
```C
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值，总是等于size-1
    unsigned long sizemask;
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;
```
table属性是一个数组，数组中的每一个元素都是指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。  

#### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：  
```C
typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```
key属性保存着键值对中的键；  
v属性保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者可以是一个int64_t整数；  
next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突的问题。

#### 4.1.3 字典
Redis中的字典由dict.h/dict结构表示：  
```Ctypedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dict ht[2];
    // rehash索引
    // 当rehash不在进行时，值为-1
    int trehashidx;
} dict;
```
type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同类型特定函数。  
privdata属性则保存了需要传给那些类型特定函数的可选参数。  
```C
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction) (const void *key);
    // 复制键的函数
    void *(*keyDup) (void *privdata, const void *key);
    // 复制值的函数
    void *(valDup) (void *privdata, const void *obj);
    // 对比键的函数
    int (*keyCompare) (void *privdata, const void *key1, const void *key2);
    // 销毁键的函数
    void (*keyDestructor) (void privdata, void *key);
    // 销毁值的函数
    void (*valDestructor) (void *privdata, void *obj);
} dictType;
```
ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]表，ht[1]表只会在ht[0]进行rehash时使用。  
rehashidx记录了rehash目前的进度，如果目前没有在进行rehash，那么他的值为-1。

### 4.2 哈希算法
当要将一个新的键值对添加到字典里面，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

### 4.3 解决键冲突
当有两个以上的键被分配到哈希表数组的同一个索引上面时，我们成这些键发生了冲突。  
Redis的哈希表使用链地址法来解决键冲突，为了考虑速度，程序总是将新节点添加到链表的表头位置。

### 4.4 rehash
当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。  
扩展和收缩哈希表的工作可以通过执行rehash操作来完成，Redis对字典的哈希表执行rehash的步骤如下：  
1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（即ht[0].used属性的值）；  
    如果执行的时扩展的操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2的n次幂；  
    如果执行的时收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次幂。  
2. 将保存再ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上；  
3. 当ht[0]包含的所有键值对都迁移到ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。  

### 4.5 渐进式rehash
rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式的完成。  
因为当键值对的数量过大时，要一次性将所有键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。  
渐进式rehash步骤：  
1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；  
2. 在字典中维持一个索引计数器变量rehashidx，并将他的值设置为0，表示rehash工作正是开始；  
3. 在rehash期间，每次对字典进行增删改查操作时，程序除了执行指定操作外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当
rehash工作完成之后，程序将rehashidx属性的值加一；  
4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx设置为-1，表示rehash操作完成。  
由于在渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新操作会在两个哈希表上进行。  
例如，要在字典中查找一个键的话，会先查ht[0]，没找到再去查ht[1]。  
增加键值对只保存到ht[1],这一措施保证ht[0]的键值对数量只减不增，并随着rehash执行而最终变成空表。  

## 第五章 跳跃表
跳跃表是一种有序数据结构，他通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
跳跃表支持平均O(logn)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
如果一个有序集合包含的元素数量比较多，或者有序集合中元素的成员是比较长的字符串时，Redis会使用跳跃表来作为有序集合键的底层实现。
Redis只在两个地方用到跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。
### 5.1 跳跃表的实现
Redis跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，zskiplistNode用于表示跳跃表节点，zskiplist则保存跳跃表节点的相关
信息，如节点数量等。
zskiplist结构的属性：
1.header：指向跳跃表的表头节点；
2.tail：指向跳跃表的表尾节点；
3.level：记录目前跳跃表内，层数最大的哪个节点的层数（表头节点的层数不计算在内）；
4.length：记录跳跃表的长度，也就是跳跃表目前包含节点的数量（表头节点不计算在内）。
#### 5.1.1 跳跃表节点
跳跃表节点由redis.h/zskiplistNode结构定义：
```C
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```
1、层
跳跃表的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序就可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，
访问其他节点的速度就越快。
每次创建一个新跳跃表节点的时候，程序都会根据幂次定律（越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度。
2、前进指针
每一层都有一个指向表尾方向的前进指针，level[i].forward属性，用于从表头向表尾访问节点。
3、跨度
层的跨度用于记录两个节点之间的距离：
两个节点之间的跨度越大，他们相距越远；
指向null的所有前进指针的跨度为0，因为他们没有连向任何节点。
跨度是用来计算排位的，在查找某个节点的过程中，将沿途访问过的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位。
4、后退指针
用于从表尾向表头访问节点，跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。
5、分值和成员
节点的分值是一个double类型的数，跳跃表中的所有节点都按分值从小到大排序。
节点的成员对象是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。
在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序。
#### 5.1.2 跳跃表
仅靠多个跳跃表节点就可以组成一个跳跃表，但通过使用一个zskiplist结构来持有这些节点，程序可以更方便的对整个跳跃表进行处理。
zskiplist结构的定义如下：
```C
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header,*tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```
### 第六章 整数集合
整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素并且这个元素集合的数量不多时，Redis就会使用整数集合作为集合键的底层实现。
#### 6.1 整数集合的实现
整数集合可以保存类型为int16_t、int32_t、int64_t的整数值，每个intset.h/inset结构表示一个整数集合：
```C
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```
contents数组是整数集合的底层实现，整数集合的每个元素都是contents数组的一个数据项，各个项在数组中按值的大小从小到大有序的排列，并且不包含重复项。
length属性记录了整数集合包含的元素数量，即contents数组的长度。
contents虽然是int8_t类型，但实际上数组并不保存int8_t类型的值，真正的类型取决于encoding属性的值：
#### 6.2 升级
每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加进去。
升级整数集合并添加新元素共分为三部进行：
1、根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间；
2、将底层数组现有的所有元素都转化为与新元素相同的类型，并将类型转换后的元素放置到正确的位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性。
3、将新元素添加到底层数组里面。
#### 6.3 升级的好处
##### 6.3.1 提升灵活性
因为C语言时静态类型语言，为了避免类型错误，我们通常不会讲两种不同类型的值放在同一个数据结构里面。
通过升级底层数组来适应新元素，而不必担心出现类型错误，这种做法非常灵活。
##### 6.3.2 节约内存
当然我们可以直接使用int64_t类型作为整数集合的底层实现，不过这样会出现浪费内存的情况。
#### 6.4 降级
整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

### 第七章 压缩列表
压缩列表ziplist是列表键和哈希键的底层实现之一。
当一个列表键只包含少量列表项，并且每个列表项要么是小整数值，要么即使长度比较短的字符串，那么就会使用压缩列表来做列表键的底层实现。
另外，当一个哈希键只包含少量键值对，且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么就会使用压缩列表来作哈希键的底层实现。
#### 7.1 压缩列表的构成
压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节
数组或者一个整数值。

### 第八章 对象
Redis并没有直接使用SDS、双端链表、字典、压缩列表、整数集合等数据结构，而是基于这些数据结构，创建了一个对象系统，这个系统包含字符串对象、列表对象、
哈希对象、集合对象、有序集合对象。

#### 8.1 对象的类型和编码
Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），一个
对象用作键值对的值（值对象）。
Redis中的每个对象都由一个redisObject结构表示：
```C
    typedef struct redisObject {
        // 类型
        unsigned type:4;
        // 编码
        unsigned encoding:4;
        // 指向底层实现数据结构的指针
        void *ptr;
        // ...
    } robj;
```

##### 8.1.1 类型
对象的type属性记录了对象的类型，他的值可以是REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET.
对于Redis保存的键值对来说，键总是一个字符串对象，而值可以是其他对象。因此：
当我们称呼一个数据库键为“字符串键”时，我们指的是，这个数据库键所对应的值为字符串对象；
当我们称呼一个数据库键位“列表键”时，我们指的是，这个数据库键所对应的值为列表对象；
以此类推。

##### 8.1.2 编码和底层实现
对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。对象的编码：
|编码常量|编码所对应的底层数据结构|
|-|-|
|REDIS_ENCODING_INT|long类型的整数|
|REDIS_ENCODING_EMBSTR|embstr编码的简单动态字符串|
|REDIS_ENCODING_RAW|简单动态字符串|
|REDIS_ENCODING_HT|字典|
|REDIS_ENCODING_LINKEDLIST|双端链表|
|REDIS_ENCODING_ZIPLIST|压缩列表|
|REDIS_ENCODING_INTSET|整数集合|
|REDIS_ENCODING_SKIPLIST|跳表|


### 第九章 数据库
